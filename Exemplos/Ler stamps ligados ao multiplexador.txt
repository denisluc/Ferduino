// Este programa faz a leitura de 4 "stamps" da "Atlas scientific" ligados a um multiplexador.

//http://atlas-scientific.com/product_pages/embedded/rs-232.html
//http://atlas-scientific.com/product_pages/embedded/ph.html
//http://atlas-scientific.com/product_pages/embedded/orp.html
//http://atlas-scientific.com/product_pages/embedded/ec.html

// Este arquivo deve ser salvo com a extensão .ino

const int multiplexPIN1 = A14; // S0
const int multiplexPIN2 = A15; //S1

char sensorstring[15];
byte holding;
short i;
short ph1=0; //Y0
short ph2=1; //Y1
short orp=2; //Y2
short ec=3; //Y3
short done=0;
float PHT; // PH temporário.
float PHA;
float PHR;
int ORP;
int ORPT; //ORP temporária
int DEN;
int DENT; //Densidade temporária.

void setup()
{
  Serial3.begin(38400);
  Serial.begin(38400);
  pinMode(multiplexPIN1, OUTPUT);
  pinMode(multiplexPIN2, OUTPUT);
}

void loop() 
{
  delay(2000);
  do{
    Open_channel(ph1);
    Serial3.print("r"); //Para se obter um valor compensado pode-se enviar um valor de temperatura da água.
    Serial3.print('\r');
    delay(1100);

    if(Serial3.available() > 3) 
    {
      holding = Serial3.available();
      for(i=1; i <= holding; i++)
      {
        sensorstring[i]= Serial3.read();
      }
      Serial.print("PH do aquario:");

      if(holding ==5)
      {
        PHT = ((sensorstring[1]-48)*100 + (sensorstring[3]-48)*10 + (sensorstring[4]-48));
        PHA = PHT/100;
      }
      else
      {
        PHT = ((sensorstring[1]-48)*1000 + (sensorstring[2]-48)*100 + (sensorstring[4]-48)*10 + (sensorstring[5]-48));
        PHA = PHT/100;
      }  
      PHT=0;
      Serial.println(PHA);
      Serial3.flush();
      break;
    }
  } 
  while (done==1);
  done=0;

  do{
    Open_channel(ph2);
    Serial3.print("r"); //Para se obter um valor compensado pode-se enviar um valor de temperatura da água.
    Serial3.print('\r');
    delay(1100);

    if(Serial3.available() > 3) 
    {
      holding = Serial3.available();
      for(i=1; i <= holding; i++)
      {
        sensorstring[i]= Serial3.read();
      }
      Serial.print("PH do reator:");
      if(holding ==5)
      {
        PHT = ((sensorstring[1]-48)*100 + (sensorstring[3]-48)*10 + (sensorstring[4]-48));
        PHR = PHT/100;
      }
      else
      {
        PHT = ((sensorstring[1]-48)*1000 + (sensorstring[2]-48)*100 + (sensorstring[4]-48)*10 + (sensorstring[5]-48));
        PHR = PHT/100;
      }  
      PHT=0;
      Serial.println(PHR);
      Serial3.flush();
      break;
    }

  } 
  while (done==1);
  done=0;

  do{
    Open_channel(orp);
    Serial3.print("r"),
    Serial3.print('\r');
    delay(1100);

    if(Serial3.available() > 3) 
    {
      holding = Serial3.available();
      for(i=1; i <= holding; i++)
      {
        sensorstring[i]= Serial3.read();
      }
      Serial.print("ORP:");
      ORPT = ((sensorstring[1]-48)*100 + (sensorstring[2]-48)*10 + (sensorstring[3]-48));
      ORP = ORPT; 
      ORPT=0;
      Serial.println(ORP);
      Serial3.flush();      
      break;
    }
  } 
  while (done==1);
  done=0;

  do{
    Open_channel(ec);
    Serial3.print("r"); //Para se obter um valor compensado pode-se enviar um valor de temperatura da água.
    Serial3.print('\r');
    delay(1100);
    if(Serial3.available() > 3) 
    {
      Serial.print("Densidade:");
      holding = Serial3.available();
      for(i=1; i <= 15; i++)
      {
        sensorstring[i]= Serial3.read();
        Serial.print(sensorstring[i]);
      }
      Serial.println();
      Serial3.flush();
      break;
    }  
  } 
  while (done==1);
  done=0;

}
void Open_channel(short channel)
{
  switch (channel) 
  {
  case 0:
    //open channel Y0
    //S0=0
    //S1=0
    digitalWrite(multiplexPIN1, LOW);
    digitalWrite(multiplexPIN2, LOW);
    break;

  case 1:
    //open channel Y1
    //S0=1
    //S1=0
    digitalWrite(multiplexPIN1, HIGH);
    digitalWrite(multiplexPIN2, LOW);
    break;

  case 2:
    //open channel Y2
    //S0=0
    //S1=1
    digitalWrite(multiplexPIN1, LOW);
    digitalWrite(multiplexPIN2, HIGH);
    break;

  case 3:
    //open channel Y3
    //S0=1
    //S1=1
    digitalWrite(multiplexPIN1, HIGH);
    digitalWrite(multiplexPIN2, HIGH);
    break;
  }
  Serial3.print('\r');
  return;
}




